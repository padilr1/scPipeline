---
title: "Seurat scRNAseq Workflow"
author: "Reinnier Padilla"
date: "November 3, 2025"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Set up

```{r,warning=FALSE,message=FALSE}
library(data.table)
library(tidyverse)
library(Seurat)
library(patchwork)
library(reactable)
```

# MacCarroll retina

I will be going over analysis of single-cell RNA-seq data from mouse retina, obtained at postnatal day 14. Fresh tissue was dissected, dissociated, and the cell suspension was immediately subjected to the Drop-seq protocol for cell capture and sequencing.

I will start from the Drop-seq output (a matrix of read counts per gene, per cell) of the MacCarrol samples, and perform basic quality control, dimensionality reduction and clustering. Afterwards, I will move onto analyzing the cell populations obtained, infer their cell-type identity and obtain their gene signatures.

## Import

Load gene count estimates per cell, and build the basic Seurat object

```{r}
set.seed(42)
DGEmatrix <- data.table::fread('Dropseq_p14_retina_Mccarroll.txt', sep = "\t") %>% 
  data.frame(row.names = 1)

# create our base Seurat object, discarding cells that have less than 100 genes
# and discarding genes that are expressed in less than 3 cells. 
Seurat_object <- Seurat::CreateSeuratObject(DGEmatrix, assay = "RNA",
                                    min.cells = 3, min.features = 100,
                                    project = "Mccarroll_retina")

# number of genes and cells
dim(DGEmatrix)
```

## QC

Compute some QC metrics that reflect the overall quality of the sample: coverage (\# of genes, \# of UMIs) and mitochondrial read proportions -- which is often an indicator of stress/cell damage

```{r}
# pull the counts matrix
counts <- Seurat::GetAssayData(Seurat_object, assay = "RNA", slot = "counts")

# get a list of mitochondrial genes: all genes starting with 'MT'
mito.genes <- grep("^MT-", rownames(counts), value = TRUE)

# compute proportions - measurement of mitochondrial gene proportion
percent.mito <- Matrix::colSums(counts[mito.genes,]) /
  Matrix::colSums(counts)

# add the information back to the seurat object
Seurat_object <- AddMetaData(object = Seurat_object, metadata = percent.mito,
                             col.name = "percent.mito")

# get a list of crystal genes (all genes starting by 'CRY') to remove crystalin contamination
crystal.genes <- grep("^CRY[AB]", rownames(x = Seurat_object@assays$RNA), value = TRUE)

# compute proportions
percent.crystal <- Matrix::colSums(counts[crystal.genes, ]) / 
  Matrix::colSums(counts)

# add the information back to the seurat object
Seurat_object <- AddMetaData(object = Seurat_object, metadata = percent.crystal,
                             col.name = "percent.crystal")

# display distribution of some metrics:
# # of genes, # of UMIs, and mitochondrial/crystal proportion
fts <- c("nFeature_RNA", "nCount_RNA", "percent.mito", "percent.crystal")
Seurat::VlnPlot(object = Seurat_object, ncol = 4, pt.size = 0, features = fts)
```

```{r}
# Get some summary stats for the sample:
summary_stats_before_filtering <- tibble(
  total_cells  = nrow(Seurat_object@meta.data),
  mean_n_genes = mean(Seurat_object@meta.data$nFeature_RNA),
  sd_n_genes   = sd(Seurat_object@meta.data$nFeature_RNA),
  max_n_genes  = max(Seurat_object@meta.data$nFeature_RNA),
  min_n_genes  = min(Seurat_object@meta.data$nFeature_RNA),
  mean_UMI     = mean(Seurat_object@meta.data$nCount_RNA),
  sd_UMI       = sd(Seurat_object@meta.data$nCount_RNA),
  max_UMI      = max(Seurat_object@meta.data$nCount_RNA),
  min_UMI      = min(Seurat_object@meta.data$nCount_RNA)
) %>% mutate_all(function(x) round(x, 2))

summary_stats_before_filtering %>% reactable::reactable()
```

## Filtering

We saw that the distribution of some metrics showed some low quality cells. Although those are not many cells, they can bother for clustering and cell-type identification. Let's get rid of the worst offenders, and recompute QC metrics

```{r}
# We'll define some cutoffs to remove cells that deviate too much from the rest of the
# cells in the sample. These can be hard cut-offs or dataset-specific ones based on SD.
# Sometimes those represent multiplets, or just abnormal cells like crystalin cells
Seurat_object <- subset(Seurat_object,  subset = nFeature_RNA > 100 & nFeature_RNA < 6000 & 
                          nCount_RNA < 10000 & percent.mito < 0.10 & percent.crystal < 0.025)
VlnPlot(object = Seurat_object, pt.size = 0, ncol = 4, features = fts)
```

```{r}
# Get some summary stats for the sample:
summary_stats_after_filtering <- tibble(
  total_cells  = nrow(Seurat_object@meta.data),
  mean_n_genes = mean(Seurat_object@meta.data$nFeature_RNA),
  sd_n_genes   = sd(Seurat_object@meta.data$nFeature_RNA),
  max_n_genes  = max(Seurat_object@meta.data$nFeature_RNA),
  min_n_genes  = min(Seurat_object@meta.data$nFeature_RNA),
  mean_UMI     = mean(Seurat_object@meta.data$nCount_RNA),
  sd_UMI       = sd(Seurat_object@meta.data$nCount_RNA),
  max_UMI      = max(Seurat_object@meta.data$nCount_RNA),
  min_UMI      = min(Seurat_object@meta.data$nCount_RNA)
) %>% mutate_all(function(x) round(x, 2))

summary_stats_after_filtering %>% reactable()
```

------------------------------------------------------------------------

```{r}
print(
  paste0("Number of filtered cells: ",
         summary_stats_before_filtering$total_cells -
           summary_stats_after_filtering$total_cells
  )
)
```

Not much was removed, only a few outlier cells, because this was a quite good quality data to begin with. In other datasets, the before/after QC metrics will look much more different.

------------------------------------------------------------------------

## Normalization

Normalize the dataset using [SCTransform](https://satijalab.org/seurat/articles/sctransform_vignette.html)

```{r}
# normalize dataset
Seurat_object <- NormalizeData(Seurat_object)

# before proceeding, we note markers for cell cycle
Seurat_object <- CellCycleScoring(Seurat_object, set.ident = FALSE,
                                  s.features = cc.genes$s.genes,
                                  g2m.features = cc.genes$g2m.genes)

# we then go on to apply a transforms the data and regresses out unwanted variation
vs <- c("nFeature_RNA", "percent.mito", "S.Score", "G2M.Score")
Seurat_object <- SCTransform(Seurat_object, verbose = T,
                             vars.to.regress = vs)

FeatureScatter(Seurat_object, feature1 = "nCount_RNA", feature2 = "percent.mito") +
  FeatureScatter(Seurat_object, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") &
  theme(legend.position = 'none')
```

------------------------------------------------------------------------

## Dimension reduction

### PCA

We will perform a first dimension reduction by using only the most variable genes. Then, we'll transform the data using principal component analysis (PCA), and use only the first few components for downstream analyses.

```{r}
# a bit of wrangling to prepare for VariableFeaturePlot
Seurat_object[['SCT']]@meta.features <- SCTResults(Seurat_object[['SCT']], slot = 'feature.attributes')[, c('gmean', 'variance', 'residual_variance')]
Seurat_object[['SCT']]@meta.features$variable <- F
Seurat_object[['SCT']]@meta.features[VariableFeatures(Seurat_object[['SCT']]), 'variable'] <- F
colnames(Seurat_object[["SCT"]]@meta.features) <- paste0("sct.", colnames(Seurat_object[["SCT"]]@meta.features))

# label top 10 most variable features
VariableFeaturePlot(Seurat_object, selection.method = 'sct', assay = 'SCT') %>%
  LabelPoints(points = head(VariableFeatures(Seurat_object), 10), repel = T) &
  theme(legend.position = 'none')
```

------------------------------------------------------------------------

```{r}
# perform PCA
Seurat_object <- RunPCA(Seurat_object, pcs.compute = 100, do.print = F)

# display genes correlated with PCs 1 & 2
VizDimLoadings(Seurat_object, dims = 1:2, reduction = "pca")
```

------------------------------------------------------------------------

```{r}
# alternative representation of genes highly correlated with PC1
DimHeatmap(Seurat_object, dims = 1:15, cells = 500, balanced = T)
```

------------------------------------------------------------------------

```{r}
# inspect the standard deviation of each PC
ElbowPlot(Seurat_object)
```

------------------------------------------------------------------------

```{r}
# assess effect of cell cycle
DimPlot(Seurat_object, reduction = "pca", group.by = "Phase")
```

------------------------------------------------------------------------

### Non-linear approaches

```{r,message=FALSE,warning=FALSE}
Seurat_object <- RunUMAP(Seurat_object, dims = 1:20)
Seurat_object <- RunTSNE(Seurat_object, dims = 1:20)
```

------------------------------------------------------------------------

## Clustering {.tabset}

```{r}
# cluster the cells based on UMAP reduction
Seurat_object <- FindNeighbors(Seurat_object, 
                               dims = 1:2, 
                               reduction = "umap")
# the resolution can be adjusted to tweak clustering accuracy
Seurat_object <- FindClusters(Seurat_object, 
                              resolution = 0.5, 
                              reduction = "umap")
```

------------------------------------------------------------------------

### UMAP

```{r}
DimPlot(Seurat_object, reduction = "umap", label = T)
```

------------------------------------------------------------------------

### tSNE

```{r}
DimPlot(Seurat_object, reduction = "tsne", label = T)
```

------------------------------------------------------------------------

### Metrics

::: superbigimage
```{r,fig.width=15,fig.height=10}
VlnPlot(object = Seurat_object, pt.size = 0.1, ncol = 1, features = fts)
```
:::

------------------------------------------------------------------------

## Identifying cell types

We now have some clusters of cells (cell populations), but we still don't know what these cells are. One can apply differential expression analysis to find marker genes higher expressed in every given cluster as compared to all remaining cells, and then infer the cell type based on current knowledge on those genes.

```{r}
Seurat_object.markers <- FindAllMarkers(Seurat_object, only.pos = TRUE,
                                        min.pct = 0.25, logfc.threshold = 0.25)
head(Seurat_object.markers) %>% reactable()
```

We can take a look at the top 10 markers in each cluster

::: superbigimage
```{r,fig.width=20,fig.height=8}
top10 <- Seurat_object.markers %>% 
  group_by(cluster) %>% 
  slice_max(avg_log2FC, n = 10) %>%
  ungroup()
DotPlot(
  Seurat_object,
  assay = NULL,
  unique(top10$gene),
  cols = c("blue", "red"),
  col.min = -2.5,
  col.max = 2.5,
  dot.min = 0,
  dot.scale = 6,
  group.by = NULL,
  split.by = NULL,
  scale.by = "radius",
  scale.min = NA,
  scale.max = NA
) + theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5))
```
:::

Alternatively, one could directly use known marker genes or published expression profiles of purified / sorted cells.

### Known marker genes {.tabset}

```{r}
markers.retina.dotplot <- toupper(c(
  "Rho",  #Rods
  "Opn1mw", #Cones
  "Trpm1", #Bipolar cells
  "Scgn", #Bipolar cells
  "Celf4", #Amacrine cells
  "Rgs5", #Pericytes
  "Cldn5", #Endothelial cells
  "Lyz2", #Immune cells
  "Glul", # Muller glia
  "Gfap", #Astrocytes
  "Optc", #Lens cells
  "Lhx1"  #Horizontal cells
))
```

#### Example

```{r}
Seurat_object <- MacCarroll_dataset$seurat

DefaultAssay(Seurat_object) <- 'RNA'
FeaturePlot(Seurat_object, features = 'TRPM1', reduction = 'umap')
```

#### Dot plots

```{r}
DefaultAssay(Seurat_object) <- 'SCT'
DotPlot(
  Seurat_object,
  assay = NULL,
  markers.retina.dotplot,
  cols = c("blue", "red"),
  col.min = -2.5,
  col.max = 2.5,
  dot.min = 0,
  dot.scale = 6,
  group.by = NULL,
  split.by = NULL,
  scale.by = "radius",
  scale.min = NA,
  scale.max = NA
) + theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5))
```

#### Violin plots

```{r}
DefaultAssay(Seurat_object) <- 'SCT'
VlnPlot(object = Seurat_object, features = markers.retina.dotplot, pt.size = 0.1, stack=TRUE)
```

------------------------------------------------------------------------

## Annotation

Assigning cluster labels based on the provided information

```{r,message=FALSE,warning=FALSE,eval=FALSE}
DefaultAssay(Seurat_object) <- 'SCT'
Seurat_object <- SetIdent(Seurat_object, cells = NULL, value="seurat_clusters")
new.cluster.ids <- c("",     # cluster 0
                     "",     # cluster 1
                     "",     # cluster 2
                     "",     # cluster 3
                     "",     # cluster 4
                     "",     # cluster 5
                     "",     # cluster 6
                     "",     # cluster 7
                     "",     # cluster 8
                     "",     # cluster 9
                     "",     # cluster 10
                     "",     # cluster 11
                     "",     # cluster 12
                     "",     # cluster 13
                     "",     # cluster 14
                     "",     # cluster 15
                     "",     # cluster 16
                     "",     # cluster 17
                     "",     # cluster 18
                     "",     # cluster 19
                     ""      # cluster 20
)
names(new.cluster.ids) <- levels(Seurat_object)
Seurat_object <- RenameIdents(Seurat_object, new.cluster.ids)

Seurat_object[["Cell_Type"]] <- Idents(object = Seurat_object)

DimPlot(Seurat_object, reduction = "umap", label = T)
```

# test
```{r}
MacCarroll_dataset <- run_scRNAseq(mat = "~/Documents/HGEN_663/extra/lec8/Dropseq_p14_retina_Mccarroll.txt",proj_name = "Mccarroll_retina")

MacCarroll_dataset
```

